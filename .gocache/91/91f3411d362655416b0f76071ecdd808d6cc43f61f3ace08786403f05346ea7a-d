// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/tibfox/go/pkg/mod/github.com/second-state/!wasm!edge-go@v0.13.4/wasmedge/hostfunc.go:1:1
package wasmedge

// #include <wasmedge/wasmedge.h>
import _ "unsafe"
import (
	"reflect"
	"sync"
	"unsafe"
)

type hostFunctionSignature func(data interface{}, callframe *CallingFrame, params []interface{}) ([]interface{}, Result)

type hostFunctionManager struct {
	mu sync.Mutex
	// Valid next index of map. Use and increase this index when gc is empty.
	idx uint
	// Recycled entries of map. Use entry in this slide when allocate a new host function.
	gc    []uint
	data  map[uint]interface{}
	funcs map[uint]hostFunctionSignature
}

func (self *hostFunctionManager) add(hostfunc hostFunctionSignature, hostdata interface{}) uint {
	self.mu.Lock()
	defer self.mu.Unlock()

	var realidx uint
	if len(self.gc) > 0 {
		realidx = self.gc[len(self.gc)-1]
		self.gc = self.gc[0 : len(self.gc)-1]
	} else {
		realidx = self.idx
		self.idx++
	}
	self.funcs[realidx] = hostfunc
	self.data[realidx] = hostdata
	return realidx
}

func (self *hostFunctionManager) get(i uint) (hostFunctionSignature, interface{}) {
	self.mu.Lock()
	defer self.mu.Unlock()
	return self.funcs[i], self.data[i]
}

func (self *hostFunctionManager) del(i uint) {
	self.mu.Lock()
	defer self.mu.Unlock()
	delete(self.funcs, i)
	delete(self.data, i)
	self.gc = append(self.gc, i)
}

var hostfuncMgr = hostFunctionManager{
	idx:   0,
	data:  make(map[uint]interface{}),
	funcs: make(map[uint]hostFunctionSignature),
}

//export wasmedgego_HostFuncInvokeImpl
func wasmedgego_HostFuncInvokeImpl(fn uintptr, data * /*line :61:54*/_Ctype_void /*line :61:60*/, callframe * /*line :61:73*/_Ctype_WasmEdge_CallingFrameContext /*line :61:103*/, params * /*line :61:113*/_Ctype_WasmEdge_Value /*line :61:129*/, paramlen  /*line :61:140*/_Ctype_uint32_t /*line :61:150*/, returns * /*line :61:161*/_Ctype_WasmEdge_Value /*line :61:177*/, returnlen  /*line :61:189*/_Ctype_uint32_t /*line :61:199*/)  /*line :61:201*/_Ctype_WasmEdge_Result /*line :61:218*/ {
	gocallgrame := &CallingFrame{
		_inner: callframe,
	}

	goparams := make([]interface{}, uint(paramlen))
	var cparams [] /*line :67:16*/_Ctype_WasmEdge_Value /*line :67:32*/
	if paramlen > 0 {
		sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&cparams)))
		sliceHeader.Cap = int(paramlen)
		sliceHeader.Len = int(paramlen)
		sliceHeader.Data = uintptr(unsafe.Pointer(params))
		for i := 0; i < int(paramlen); i++ {
			goparams[i] = fromWasmEdgeValue(cparams[i])
			if cparams[i].Type == ( /*line :75:26*/_Ciconst_WasmEdge_ValType_ExternRef /*line :75:53*/) && !goparams[i].(ExternRef)._valid {
				panic("External reference is released")
			}
		}
	}

	gofunc, godata := hostfuncMgr.get(uint(fn))
	goreturns, err := gofunc(godata, gocallgrame, goparams)

	var creturns [] /*line :84:17*/_Ctype_WasmEdge_Value /*line :84:33*/
	if returnlen > 0 && goreturns != nil {
		sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&creturns)))
		sliceHeader.Cap = int(returnlen)
		sliceHeader.Len = int(returnlen)
		sliceHeader.Data = uintptr(unsafe.Pointer(returns))
		for i, val := range goreturns {
			if i < int(returnlen) {
				creturns[i] = toWasmEdgeValue(val)
			}
		}
	}

	return  /*line :97:9*/_Ctype_WasmEdge_Result /*line :97:26*/{Code:  /*line :97:33*/_Ctype_uint32_t /*line :97:43*/(err.code)}
}
