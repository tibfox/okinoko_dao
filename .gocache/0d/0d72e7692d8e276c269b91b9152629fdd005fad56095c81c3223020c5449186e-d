// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/tibfox/go/pkg/mod/github.com/second-state/!wasm!edge-go@v0.13.4/wasmedge/value.go:1:1
package wasmedge

// #include <wasmedge/wasmedge.h>
import _ "unsafe"
import (
	"encoding/binary"
	"fmt"
	"reflect"
	"sync"
	"unsafe"
)

type ValType  /*line :13:14*/_Ctype_enum_WasmEdge_ValType /*line :13:37*/
type RefType  /*line :14:14*/_Ctype_enum_WasmEdge_RefType /*line :14:37*/
type ValMut  /*line :15:13*/_Ctype_enum_WasmEdge_Mutability /*line :15:39*/

const (
	ValType_I32       = ValType(( /*line :18:30*/_Ciconst_WasmEdge_ValType_I32 /*line :18:51*/))
	ValType_I64       = ValType(( /*line :19:30*/_Ciconst_WasmEdge_ValType_I64 /*line :19:51*/))
	ValType_F32       = ValType(( /*line :20:30*/_Ciconst_WasmEdge_ValType_F32 /*line :20:51*/))
	ValType_F64       = ValType(( /*line :21:30*/_Ciconst_WasmEdge_ValType_F64 /*line :21:51*/))
	ValType_V128      = ValType(( /*line :22:30*/_Ciconst_WasmEdge_ValType_V128 /*line :22:52*/))
	ValType_FuncRef   = ValType(( /*line :23:30*/_Ciconst_WasmEdge_ValType_FuncRef /*line :23:55*/))
	ValType_ExternRef = ValType(( /*line :24:30*/_Ciconst_WasmEdge_ValType_ExternRef /*line :24:57*/))
)

const (
	RefType_FuncRef   = RefType(( /*line :28:30*/_Ciconst_WasmEdge_ValType_FuncRef /*line :28:55*/))
	RefType_ExternRef = RefType(( /*line :29:30*/_Ciconst_WasmEdge_ValType_ExternRef /*line :29:57*/))
)

const (
	ValMut_Const = ValMut(( /*line :33:24*/_Ciconst_WasmEdge_Mutability_Const /*line :33:50*/))
	ValMut_Var   = ValMut(( /*line :34:24*/_Ciconst_WasmEdge_Mutability_Var /*line :34:48*/))
)

func (self ValType) String() string {
	switch self {
	case ValType_I32:
		return "i32"
	case ValType_I64:
		return "i64"
	case ValType_F32:
		return "f32"
	case ValType_F64:
		return "f64"
	case ValType_V128:
		return "v128"
	case ValType_FuncRef:
		return "funcref"
	case ValType_ExternRef:
		return "externref"
	}
	panic("Unknown value type")
}

func (self RefType) String() string {
	switch self {
	case RefType_FuncRef:
		return "funcref"
	case RefType_ExternRef:
		return "externref"
	}
	panic("Unknown reference type")
}

func (self ValMut) String() string {
	switch self {
	case ValMut_Const:
		return "const"
	case ValMut_Var:
		return "var"
	}
	panic("Unknown value mutability")
}

type externRefManager struct {
	mu sync.Mutex
	// Valid next index of map. Use and increase this index when gc is empty.
	idx uint
	// Recycled entries of map. Use entry in this slide when allocate a new external reference.
	gc  []uint
	ref map[uint]interface{}
}

func (self *externRefManager) add(ptr interface{}) uint {
	self.mu.Lock()
	defer self.mu.Unlock()

	var realidx uint
	if len(self.gc) > 0 {
		realidx = self.gc[len(self.gc)-1]
		self.gc = self.gc[0 : len(self.gc)-1]
	} else {
		realidx = self.idx
		self.idx++
	}
	self.ref[realidx] = ptr
	return realidx
}

func (self *externRefManager) get(i uint) interface{} {
	self.mu.Lock()
	defer self.mu.Unlock()
	return self.ref[i]
}

func (self *externRefManager) del(i uint) {
	self.mu.Lock()
	defer self.mu.Unlock()
	delete(self.ref, i)
	self.gc = append(self.gc, i)
}

var externRefMgr = externRefManager{
	/// Index = 0 is reserved for ref.null
	idx: 1,
	ref: make(map[uint]interface{}),
}

type FuncRef struct {
	_inner  /*line :122:9*/_Ctype_WasmEdge_Value /*line :122:25*/
}

func NewFuncRef(funcinst *Function) FuncRef {
	return FuncRef{
		_inner: func() _Ctype_struct_WasmEdge_Value{ _cgo0 := /*line :127:38*/funcinst._inner; _cgoCheckPointer(_cgo0, nil); return /*line :127:54*/_Cfunc_WasmEdge_ValueGenFuncRef(_cgo0); }(),
	}
}

func (self FuncRef) GetRef() *Function {
	funcinst := ( /*line :132:14*/_Cfunc_WasmEdge_ValueGetFuncRef /*line :132:39*/)(self._inner)
	if funcinst != nil {
		return &Function{_inner: funcinst, _own: false}
	}
	return nil
}

type ExternRef struct {
	_inner  /*line :140:9*/_Ctype_WasmEdge_Value /*line :140:25*/
	_valid bool
}

func NewExternRef(ptr interface{}) ExternRef {
	// Gen an i64 WasmEdge_Value and change type to WasmEdge_ValType_ExternRef
	idx := uint64(externRefMgr.add(ptr))
	val := ( /*line :147:9*/_Cfunc_WasmEdge_ValueGenI64 /*line :147:30*/)( /*line :147:32*/_Ctype_int64_t /*line :147:41*/(idx))
	val.Type = ( /*line :148:13*/_Ciconst_WasmEdge_ValType_ExternRef /*line :148:40*/)
	return ExternRef{
		_inner: val,
		_valid: true,
	}
}

func (self ExternRef) Release() {
	self._valid = false
	// Change type back to WasmEdge_ValType_I64 and get the i64 value
	idx := uint(( /*line :158:14*/_Cfunc_WasmEdge_ValueGetI64 /*line :158:35*/)(self._inner))
	externRefMgr.del(idx)
}

func (self ExternRef) GetRef() interface{} {
	if self._valid {
		// Get the original i64 value
		idx := uint(( /*line :165:15*/_Cfunc_WasmEdge_ValueGetI64 /*line :165:36*/)(self._inner))
		return externRefMgr.get(idx)
	}
	return nil
}

type V128 struct {
	_inner  /*line :172:9*/_Ctype_WasmEdge_Value /*line :172:25*/
}

func NewV128(high uint64, low uint64) V128 {
	var cval  /*line :176:11*/_Ctype___int128 /*line :176:21*/
	var buf []byte
	sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&buf)))
	sliceHeader.Cap = 16
	sliceHeader.Len = 16
	sliceHeader.Data = uintptr(unsafe.Pointer(&cval))
	binary.LittleEndian.PutUint64(buf[:8], low)
	binary.LittleEndian.PutUint64(buf[8:], high)
	return V128{
		_inner: ( /*line :185:11*/_Cfunc_WasmEdge_ValueGenV128 /*line :185:33*/)(cval),
	}
}

func (self V128) GetVal() (uint64, uint64) {
	cval := ( /*line :190:10*/_Cfunc_WasmEdge_ValueGetV128 /*line :190:32*/)(self._inner)
	var buf []byte
	sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&buf)))
	sliceHeader.Cap = 16
	sliceHeader.Len = 16
	sliceHeader.Data = uintptr(unsafe.Pointer(&cval))
	return binary.LittleEndian.Uint64(buf[8:]), binary.LittleEndian.Uint64(buf[:8])
}

func toWasmEdgeValue(value interface{})  /*line :199:41*/_Ctype_WasmEdge_Value /*line :199:57*/ {
	switch value.(type) {
	case FuncRef:
		return value.(FuncRef)._inner
	case ExternRef:
		if !value.(ExternRef)._valid {
			panic("External reference is released")
		}
		return value.(ExternRef)._inner
	case V128:
		return value.(V128)._inner
	case int:
		if unsafe.Sizeof(value.(int)) == 4 {
			return ( /*line :212:11*/_Cfunc_WasmEdge_ValueGenI32 /*line :212:32*/)( /*line :212:34*/_Ctype_int32_t /*line :212:43*/(value.(int)))
		} else {
			return ( /*line :214:11*/_Cfunc_WasmEdge_ValueGenI64 /*line :214:32*/)( /*line :214:34*/_Ctype_int64_t /*line :214:43*/(value.(int)))
		}
	case int32:
		return ( /*line :217:10*/_Cfunc_WasmEdge_ValueGenI32 /*line :217:31*/)( /*line :217:33*/_Ctype_int32_t /*line :217:42*/(value.(int32)))
	case int64:
		return ( /*line :219:10*/_Cfunc_WasmEdge_ValueGenI64 /*line :219:31*/)( /*line :219:33*/_Ctype_int64_t /*line :219:42*/(value.(int64)))
	case uint:
		if unsafe.Sizeof(value.(uint)) == 4 {
			return ( /*line :222:11*/_Cfunc_WasmEdge_ValueGenI32 /*line :222:32*/)( /*line :222:34*/_Ctype_int32_t /*line :222:43*/(int32(value.(uint))))
		} else {
			return ( /*line :224:11*/_Cfunc_WasmEdge_ValueGenI64 /*line :224:32*/)( /*line :224:34*/_Ctype_int64_t /*line :224:43*/(int64(value.(uint))))
		}
	case uint32:
		return ( /*line :227:10*/_Cfunc_WasmEdge_ValueGenI32 /*line :227:31*/)( /*line :227:33*/_Ctype_int32_t /*line :227:42*/(int32(value.(uint32))))
	case uint64:
		return ( /*line :229:10*/_Cfunc_WasmEdge_ValueGenI64 /*line :229:31*/)( /*line :229:33*/_Ctype_int64_t /*line :229:42*/(int64(value.(uint64))))
	case float32:
		return ( /*line :231:10*/_Cfunc_WasmEdge_ValueGenF32 /*line :231:31*/)( /*line :231:33*/_Ctype_float /*line :231:40*/(value.(float32)))
	case float64:
		return ( /*line :233:10*/_Cfunc_WasmEdge_ValueGenF64 /*line :233:31*/)( /*line :233:33*/_Ctype_double /*line :233:41*/(value.(float64)))
	default:
		panic("Wrong argument of toWasmEdgeValue()")
	}
}

func fromWasmEdgeValue(value  /*line :239:30*/_Ctype_WasmEdge_Value /*line :239:46*/) interface{} {
	switch value.Type {
	case ( /*line :241:7*/_Ciconst_WasmEdge_ValType_I32 /*line :241:28*/):
		return int32(( /*line :242:16*/_Cfunc_WasmEdge_ValueGetI32 /*line :242:37*/)(value))
	case ( /*line :243:7*/_Ciconst_WasmEdge_ValType_I64 /*line :243:28*/):
		return int64(( /*line :244:16*/_Cfunc_WasmEdge_ValueGetI64 /*line :244:37*/)(value))
	case ( /*line :245:7*/_Ciconst_WasmEdge_ValType_F32 /*line :245:28*/):
		return float32(( /*line :246:18*/_Cfunc_WasmEdge_ValueGetF32 /*line :246:39*/)(value))
	case ( /*line :247:7*/_Ciconst_WasmEdge_ValType_F64 /*line :247:28*/):
		return float64(( /*line :248:18*/_Cfunc_WasmEdge_ValueGetF64 /*line :248:39*/)(value))
	case ( /*line :249:7*/_Ciconst_WasmEdge_ValType_V128 /*line :249:29*/):
		return V128{_inner: value}
	case ( /*line :251:7*/_Ciconst_WasmEdge_ValType_FuncRef /*line :251:32*/):
		return FuncRef{_inner: value}
	case ( /*line :253:7*/_Ciconst_WasmEdge_ValType_ExternRef /*line :253:34*/):
		idx := uint(( /*line :254:15*/_Cfunc_WasmEdge_ValueGetI64 /*line :254:36*/)(value))
		if _, ok := externRefMgr.ref[idx]; ok {
			return ExternRef{_inner: value, _valid: true}
		}
		return ExternRef{_inner: value, _valid: false}
	default:
		panic("Wrong argument of fromWasmEdgeValue()")
	}
}

func toWasmEdgeValueSlide(vals ...interface{}) [] /*line :264:50*/_Ctype_WasmEdge_Value /*line :264:66*/ {
	cvals := make([] /*line :265:18*/_Ctype_WasmEdge_Value /*line :265:34*/, len(vals))
	for i, val := range vals {
		cvals[i] = toWasmEdgeValue(val)
	}
	return cvals
}

func toWasmEdgeValueSlideBindgen(vm *VM, rettype bindgen, modname *string, vals ...interface{}) [] /*line :272:99*/_Ctype_WasmEdge_Value /*line :272:115*/ {
	//cvals := make([]C.WasmEdge_Value, len(vals))
	cvals := [] /*line :274:13*/_Ctype_WasmEdge_Value /*line :274:29*/{}
	if rettype == Bindgen_return_array {
		// Array result address = 8
		cvals = append(cvals, ( /*line :277:25*/_Cfunc_WasmEdge_ValueGenI32 /*line :277:46*/)( /*line :277:48*/_Ctype_int32_t /*line :277:57*/(8)))
	} else if rettype == Bindgen_return_i64 {
		// wasm-bindgen magic: Set memory offset for i64 return value
		cvals = append(cvals, ( /*line :280:25*/_Cfunc_WasmEdge_ValueGenI32 /*line :280:46*/)( /*line :280:48*/_Ctype_int32_t /*line :280:57*/(0)))
	}
	for _, val := range vals {
		switch t := val.(type) {
		case FuncRef:
			panic("toWasmEdgeValueSlideBindgen(): Not support FuncRef now")
		case ExternRef:
			panic("toWasmEdgeValueSlideBindgen(): Not support ExternRef now")
		case V128:
			panic("toWasmEdgeValueSlideBindgen(): Not support v128 now")
		case int32:
			cvals = append(cvals, ( /*line :291:26*/_Cfunc_WasmEdge_ValueGenI32 /*line :291:47*/)( /*line :291:49*/_Ctype_int32_t /*line :291:58*/(val.(int32))))
		case uint32:
			cvals = append(cvals, ( /*line :293:26*/_Cfunc_WasmEdge_ValueGenI32 /*line :293:47*/)( /*line :293:49*/_Ctype_int32_t /*line :293:58*/(val.(uint32))))
		case int64:
			vall := ( /*line :295:12*/_Cfunc_WasmEdge_ValueGenI32 /*line :295:33*/)( /*line :295:35*/_Ctype_int32_t /*line :295:44*/(uint32(val.(int64))))
			valu := ( /*line :296:12*/_Cfunc_WasmEdge_ValueGenI32 /*line :296:33*/)( /*line :296:35*/_Ctype_int32_t /*line :296:44*/(uint32(val.(int64) >> 32)))
			cvals = append(cvals, vall, valu)
		case uint64:
			vall := ( /*line :299:12*/_Cfunc_WasmEdge_ValueGenI32 /*line :299:33*/)( /*line :299:35*/_Ctype_int32_t /*line :299:44*/(uint32(val.(uint64))))
			valu := ( /*line :300:12*/_Cfunc_WasmEdge_ValueGenI32 /*line :300:33*/)( /*line :300:35*/_Ctype_int32_t /*line :300:44*/(uint32(val.(uint64) >> 32)))
			cvals = append(cvals, vall, valu)
		case int:
			panic("toWasmEdgeValueSlideBindgen(): Not support int now, please use int32 or int64 instead")
		case uint:
			panic("toWasmEdgeValueSlideBindgen(): Not support uint now, please use uint32 or uint64 instead")
		case float32:
			panic("toWasmEdgeValueSlideBindgen(): Not support float32 now")
		case float64:
			panic("toWasmEdgeValueSlideBindgen(): Not support float64 now")
		case []byte:
			// Call malloc function
			mallocsize := uint32(len(val.([]byte)))
			var rets []interface{}
			var err error = nil
			if modname == nil {
				rets, err = vm.Execute("__wbindgen_malloc", mallocsize)
			} else {
				rets, err = vm.ExecuteRegistered(*modname, "__wbindgen_malloc", mallocsize)
			}
			if err != nil {
				panic("toWasmEdgeValueSlideBindgen(): malloc failed")
			}
			if len(rets) <= 0 {
				panic("toWasmEdgeValueSlideBindgen(): malloc function signature unexpected")
			}
			argaddr := ( /*line :326:15*/_Cfunc_WasmEdge_ValueGenI32 /*line :326:36*/)( /*line :326:38*/_Ctype_int32_t /*line :326:47*/(rets[0].(int32)))
			argsize := ( /*line :327:15*/_Cfunc_WasmEdge_ValueGenI32 /*line :327:36*/)( /*line :327:38*/_Ctype_int32_t /*line :327:47*/(mallocsize))
			cvals = append(cvals, argaddr, argsize)
			// Set bytes
			var mod *Module = nil
			var mem *Memory = nil
			if modname == nil {
				mod = vm.GetActiveModule()
			} else {
				store := vm.GetStore()
				mod = store.FindModule(*modname)
			}
			if mod != nil {
				memnames := mod.ListMemory()
				if len(memnames) <= 0 {
					panic("toWasmEdgeValueSlideBindgen(): memory instance not found")
				}
				mem = mod.FindMemory(memnames[0])
				mem.SetData(val.([]byte), uint(rets[0].(int32)), uint(mallocsize))
			}
		default:
			errorString := fmt.Sprintf("Wrong argument of toWasmEdgeValueSlideBindgen(): %T not supported", t)
			panic(errorString)
		}
	}
	return cvals
}

func fromWasmEdgeValueSlide(cvals [] /*line :354:37*/_Ctype_WasmEdge_Value /*line :354:53*/) []interface{} {
	if len(cvals) > 0 {
		vals := make([]interface{}, len(cvals))
		for i, cval := range cvals {
			vals[i] = fromWasmEdgeValue(cval)
		}
		return vals
	}
	return []interface{}{}
}

func fromWasmEdgeValueSlideBindgen(vm *VM, rettype bindgen, modname *string, cvals [] /*line :365:86*/_Ctype_WasmEdge_Value /*line :365:102*/) (interface{}, error) {
	returns := fromWasmEdgeValueSlide(cvals)
	switch rettype {
	case Bindgen_return_void:
		return nil, nil
	case Bindgen_return_i32:
		if len(returns) <= 0 {
			panic("Expected return i32, but got empty")
		}
		return returns[0], nil
	case Bindgen_return_i64:
		// Get memory context
		var mod *Module = nil
		var mem *Memory = nil
		if modname == nil {
			mod = vm.GetActiveModule()
		} else {
			store := vm.GetStore()
			mod = store.FindModule(*modname)
		}
		if mod != nil {
			memnames := mod.ListMemory()
			if len(memnames) > 0 {
				mem = mod.FindMemory(memnames[0])
			}
		}
		// Get int64
		if mem == nil {
			panic("fromWasmEdgeValueSlideBindgen(): memory instance not found")
		}
		buf, err := mem.GetData(0, 8)
		if err != nil {
			return nil, err
		}
		var num int64 = 0
		for i, val := range buf {
			num += int64(val) << (i * 8)
		}
		return num, nil
	case Bindgen_return_array:
		// Get memory context
		var mod *Module = nil
		var mem *Memory = nil
		if modname == nil {
			mod = vm.GetActiveModule()
		} else {
			store := vm.GetStore()
			mod = store.FindModule(*modname)
		}
		if mod != nil {
			memnames := mod.ListMemory()
			if len(memnames) > 0 {
				mem = mod.FindMemory(memnames[0])
			}
		}
		// Get address and length (array result address = 8)
		if mem == nil {
			panic("fromWasmEdgeValueSlideBindgen(): memory instance not found")
		}
		buf, err := mem.GetData(8, 8)
		if err != nil {
			return nil, err
		}
		var num int64 = 0
		for i, val := range buf {
			num += int64(val) << (i * 8)
		}
		// Get bytes
		var arraddr = int32(num)
		var arrlen = int32(num >> 32)
		buf, err = mem.GetData(uint(arraddr), uint(arrlen))
		if err != nil {
			return nil, err
		}
		// Free array
		if modname == nil {
			_, err = vm.Execute("__wbindgen_free", arraddr, arrlen)
		} else {
			_, err = vm.ExecuteRegistered(*modname, "__wbindgen_free", arraddr, arrlen)
		}
		if err != nil {
			panic("fromWasmEdgeValueSlideBindgen(): malloc failed")
		}
		return buf, nil
	default:
		panic("Wrong expected return type")
	}
}
